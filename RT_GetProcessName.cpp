/*
	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/

#include "RT_Stats.h"


#define DPRINTFNAME "RT_GetProcessName: "


AVSValue __cdecl RT_GetProcessName(AVSValue args, void*, IScriptEnvironment* env) {
/*
	bool parent= args[0].AsBool(false);
	bool debug = args[1].AsBool(false);


//	DWORD WINAPI GetCurrentProcessId(void);
//	Return value: The return value is the process identifier of the calling process.
//	Minimum supported client:- Windows XP WinBase.h (Processthreadsapi.h W8 Server 2012)
//  ssS, Rubbish, also works fine on W2K

	unsigned int PID = getpid();	// Cannot fail (I think) as current process is obviously running.





// HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags,DWORD th32ProcessID);
//
//
// The th32ProcessID argument is only used if TH32CS_SNAPHEAPLIST or
// TH32CS_SNAPMODULE is specified. th32ProcessID == 0 means the current
// process.
//
// NOTE that all of the snapshots are global except for the heap and module
//      lists which are process specific. To enumerate the heap or module
//      state for all WIN32 processes call with TH32CS_SNAPALL and the
//      current process. Then for each process in the TH32CS_SNAPPROCESS
//      list that isn't the current process, do a call with just
//      TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.
//
// dwFlags
//
// #define TH32CS_SNAPHEAPLIST 0x00000001
// #define TH32CS_SNAPPROCESS  0x00000002
// #define TH32CS_SNAPTHREAD   0x00000004
// #define TH32CS_SNAPMODULE   0x00000008
// #define TH32CS_SNAPMODULE32 0x00000010
// #define TH32CS_SNAPALL      (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)
// #define TH32CS_INHERIT      0x80000000
//
    u_int         hProcessSnap = NULL; 

    //  Take a snapshot of all processes in the system. 
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); 
	// Returns an open handle to the specified snapshot if successful or INVALID_HANDLE_VALUE otherwise. 
	// The snapshot taken by this function is examined by the other tool help functions to provide their results.
	// Access to the snapshot is read only. The snapshot handle acts like an object handle and is subject to the same
	// rules regarding which processes and threads it is valid in. 
	// To retrieve an extended error status code generated by this function, use the GetLastError function.
	// To destroy the snapshot, use the CloseHandle function.


    if (hProcessSnap == INVALID_HANDLE_VALUE) 
        return -1; 
 

// Describes an entry from a list that enumerates the processes residing in the system address space when a snapshot was taken.
//
// typedef struct tagPROCESSENTRY32 { 
//   DWORD dwSize; 
//   DWORD cntUsage; 
//   DWORD th32ProcessID; 
//   ULONG_PTR th32DefaultHeapID; 
//   DWORD th32ModuleID; 
//   DWORD cntThreads; 
//   DWORD th32ParentProcessID; 
//   LONG  pcPriClassBase; 
//   DWORD dwFlags; 
//   TCHAR szExeFile[PATH_MAX]; 
// } PROCESSENTRY32; 
// typedef PROCESSENTRY32 *PPROCESSENTRY32; 
//
// Members 
//
// dwSize 
//		Specifies the length, in bytes, of the structure. Before calling the Process32First function, set this member to
//		sizeof(PROCESSENTRY32). If you do not initialize dwSize, Process32First will fail. 
// cntUsage 
//		Number of references to the process. A process exists as long as its usage count is nonzero. As soon as its usage
//		count becomes zero, a process terminates. 
// th32ProcessID 
//		Identifier of the process. 
// th32DefaultHeapID 
//		Identifier of the default heap for the process. The contents of this member has meaning only to the tool help
//		functions. It is not a handle, nor is it usable by functions other than the ToolHelp functions. 
// th32ModuleID 
//		Module identifier of the process. The contents of this member has meaning only to the tool help functions
//		It is not a handle, nor is it usable by functions other than the ToolHelp functions. 
// cntThreads 
//		Number of execution threads started by the process. 
// th32ParentProcessID 
//		Identifier of the process that created the process being examined. 
// pcPriClassBase 
//		Base priority of any threads created by this process. 
// dwFlags 
//		Reserved; do not use. 
// szExeFile 
//		Path and filename of the executable file for the process. 
//
// Requirements:- Windows NT/2000/XP: Included in Windows 2000 and later. ::: Tlhelp32.h.

    PROCESSENTRY32 pe32			= {0}; 
    //  Fill in the size of the structure before using it. 
    pe32.dwSize = sizeof(PROCESSENTRY32); 

	

    //  Walk the snapshot of the processes, and for each process, 
	//	BOOL WINAPI Process32First(HANDLE hSnapshot,LPPROCESSENTRY32 lppe);
    if (!Process32First(hProcessSnap, &pe32)) {
	    CloseHandle (hProcessSnap); 
		return -2;			// Cant find first process
	}

	AVSValue ret =  -3;		// Init to cant find my own PID

    do {
		if(pe32.th32ProcessID == PID) {
			if(debug) {
				dprintf(DPRINTFNAME"ExeFile    = %s\n",pe32.szExeFile);
				dprintf(DPRINTFNAME"ProcessID  = 0x%08X\n",pe32.th32ProcessID);
				dprintf(DPRINTFNAME"Threads    = %d\n",pe32.cntThreads);
				dprintf(DPRINTFNAME"ParentProc = 0x%08X\n",pe32.th32ParentProcessID);
			}
			if(parent==false) {
				ret = env->SaveString(pe32.szExeFile);
			} else {
				ret = -4;		// Init Cant find parent
				DWORD PARPID = pe32.th32ParentProcessID;
				if (Process32First(hProcessSnap, &pe32)) {
					do {
						if(pe32.th32ProcessID == PARPID) {
							if(debug) {
								dprintf(DPRINTFNAME"ExeFile    = %s\n",pe32.szExeFile);
								dprintf(DPRINTFNAME"ProcessID  = 0x%08X\n",pe32.th32ProcessID);
								dprintf(DPRINTFNAME"Threads    = %d\n",pe32.cntThreads);
								dprintf(DPRINTFNAME"ParentProc = 0x%08X\n",pe32.th32ParentProcessID);
							}
							ret = env->SaveString(pe32.szExeFile);
							break;
						}
					} while (Process32Next(hProcessSnap, &pe32)); 
				}
			}
			break;		// DONE
		}
    } while (Process32Next(hProcessSnap, &pe32)); 

    CloseHandle (hProcessSnap);		// Cleanup process snapshot
	*/

	AVSValue ret =  -3;
	extern char *program_invocation_name;
	ret = env->SaveString(program_invocation_name);
    return (ret); 
}

